<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>羽球分組與記分</title>
  <style>
    :root {
      --bg: #07140e;
      --panel: #0f2c20;
      --card: #163d2c;
      --card-alt: #1d4a35;
      --text: #f6fff9;
      --muted: #bfd8ca;
      --accent: #60f5ae;
      --accent-2: #2fd889;
      --accent-3: #1aa86a;
      --court: #2b9a61;
      --court-line: #effff5;
      --serve: #ffd24d;
      --border: #2f7052;
      --ink-dark: #062116;
      --lead-a: #7cffbf;
      --lead-b: #7fe7ff;
      --trail: #9bb7aa;
      --neutral: #f6fff9;
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: radial-gradient(1000px 500px at 10% -10%, #184c35 0%, var(--bg) 50%) fixed;
      color: var(--text);
      font-family: "Segoe UI", "Noto Sans TC", sans-serif;
      padding: max(10px, env(safe-area-inset-top)) max(10px, env(safe-area-inset-right)) max(10px, env(safe-area-inset-bottom)) max(10px, env(safe-area-inset-left));
    }

    .app {
      max-width: 520px;
      margin: 0 auto;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 16px 30px rgba(0,0,0,.28);
    }

    .header {
      padding: 14px;
      background: linear-gradient(140deg, #153f2d, #0d2b1f);
      border-bottom: 1px solid var(--border);
    }

    .title-row { display: flex; justify-content: space-between; align-items: center; gap: 10px; }
    .title { margin: 0; color: var(--accent); font-size: 1.2rem; font-weight: 800; }
    .badge {
      background: var(--accent-3);
      color: var(--ink-dark);
      font-size: .72rem;
      font-weight: 800;
      padding: 4px 8px;
      border-radius: 999px;
    }
    .subtitle { margin-top: 6px; color: var(--muted); font-size: .85rem; }

    .tabs { display: flex; gap: 6px; padding: 10px; background: #0b2017; border-bottom: 1px solid var(--border); }
    .tab-btn {
      flex: 1;
      border: 1px solid var(--border);
      background: #123525;
      color: var(--text);
      padding: 10px 8px;
      border-radius: 10px;
      font-weight: 700;
      cursor: pointer;
    }
    .tab-btn.active { background: var(--accent-2); color: #072014; border-color: transparent; }

    .tab-pane { display: none; padding: 10px; }
    .tab-pane.active { display: block; }

    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px;
    }
    .section-title { color: var(--accent); font-size: 1rem; font-weight: 800; margin: 0 0 4px; }
    .muted { color: var(--muted); font-size: .88rem; }

    .list-wrap {
      max-height: 260px;
      overflow: auto;
      background: var(--card-alt);
      border: 1px solid var(--border);
      border-radius: 10px;
      margin: 8px 0;
    }
    .player-item {
      padding: 8px 10px;
      border-bottom: 1px solid rgba(255,255,255,.06);
      white-space: nowrap;
      overflow-x: auto;
      cursor: pointer;
      font-weight: 600;
    }
    .player-item:last-child { border-bottom: none; }
    .player-item.active { background: #3ec488; color: #061a11; }

    .row { display: flex; gap: 8px; align-items: center; }
    .row + .row { margin-top: 8px; }
    input, select, textarea, button {
      font: inherit;
      border-radius: 10px;
      border: 1px solid var(--border);
    }
    input, select, textarea {
      width: 100%;
      padding: 10px;
      background: var(--card-alt);
      color: var(--text);
    }
    .btn {
      background: var(--accent);
      color: #072014;
      border: none;
      padding: 10px 12px;
      font-weight: 800;
      cursor: pointer;
    }
    .btn.secondary { background: #2f8f65; color: #eafff2; }
    .btn:disabled { opacity: .5; cursor: not-allowed; }

    .schedule-out {
      white-space: pre-wrap;
      background: var(--card-alt);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px;
      min-height: 220px;
      max-height: 320px;
      overflow: auto;
      font-family: Consolas, monospace;
      font-size: .9rem;
    }

    .status-strip {
      position: relative;
      background: var(--card-alt);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 8px;
      text-align: center;
    }
    .score-line { font-size: 1.8rem; font-weight: 900; letter-spacing: .5px; }
    .score-mid { color: var(--neutral); }
    .state-text { margin-top: 3px; font-size: .9rem; color: var(--muted); font-weight: 800; }
    .server-text { margin-top: 2px; font-size: .92rem; font-weight: 700; }

    .banner {
      position: absolute;
      left: 50%;
      top: 12px;
      transform: translateX(-50%);
      background: var(--accent);
      color: var(--ink-dark);
      border-radius: 999px;
      font-weight: 900;
      font-size: 1.25rem;
      padding: 8px 18px;
      opacity: 0;
      pointer-events: none;
    }
    .banner.show { animation: popWin .1s linear infinite alternate; opacity: 1; }
    @keyframes popWin {
      from { transform: translateX(-50%) scale(1); background: var(--accent); }
      to { transform: translateX(-50%) scale(1.08); background: var(--serve); }
    }

    .court-wrap { margin-top: 10px; }
    canvas {
      width: 100%;
      height: 300px;
      background: #0e3324;
      border: 1px solid var(--border);
      border-radius: 10px;
      display: block;
    }

    .hint { margin-top: 10px; font-size: .9rem; color: var(--muted); }

    .action-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 8px;
    }
    .action-row .btn {
      flex: 1;
      min-width: 140px;
    }

    @media (max-width: 520px) {
      body { padding: 0; }
      .app {
        min-height: 100dvh;
        border-radius: 0;
        border: none;
      }
      .header {
        position: sticky;
        top: 0;
        z-index: 4;
      }
      .title { font-size: 1.02rem; }
      .subtitle { font-size: .8rem; }
      .tabs {
        position: sticky;
        top: 62px;
        z-index: 3;
        overflow-x: auto;
        padding: 8px;
      }
      .tab-btn {
        min-width: 90px;
        padding: 12px 10px;
        font-size: .92rem;
        white-space: nowrap;
      }
      .tab-pane { padding: 8px; }
      .card { padding: 10px 8px; }
      .row { flex-wrap: wrap; }
      .row.mobile-col { flex-direction: column; align-items: stretch; }
      .row.mobile-col .btn { width: 100%; }
      .list-wrap { max-height: 220px; }
      .player-item { padding: 11px 10px; }
      .score-line { font-size: 1.7rem; }
      .state-text, .server-text { font-size: .85rem; }
      canvas { height: min(300px, 52vh); }
      .schedule-out {
        min-height: 170px;
        max-height: 240px;
        font-size: .82rem;
      }
      #roundInput, #matchSelect {
        max-width: 100% !important;
      }
      .action-row {
        position: sticky;
        bottom: 0;
        background: linear-gradient(to top, rgba(15,44,32,.95), rgba(15,44,32,.8));
        padding: 8px 0 env(safe-area-inset-bottom);
      }
      .action-row .btn {
        min-height: 44px;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="header">
      <div class="title-row">
        <h1 class="title">Badminton Match Assistant</h1>
        <span class="badge">SPORT MODE</span>
      </div>
      <div class="subtitle">禮拜日打球團</div>
    </div>

    <div class="tabs">
      <button class="tab-btn active" data-tab="players">球員管理</button>
      <button class="tab-btn" data-tab="schedule">賽程</button>
      <button class="tab-btn" data-tab="scoreboard">記分板</button>
    </div>

    <section id="tab-players" class="tab-pane active">
      <div class="card">
        <h2 class="section-title">球員管理</h2>
        <div class="muted">球員名單（建議 6-12 人）</div>
        <div id="playerList" class="list-wrap"></div>
        <div class="row"><input id="playerInput" placeholder="輸入球員名字" /></div>
        <div class="row mobile-col">
          <button id="addPlayerBtn" class="btn">新增球員</button>
          <button id="editPlayerBtn" class="btn secondary">修改選取</button>
          <button id="delPlayerBtn" class="btn secondary">刪除選取</button>
        </div>
        <div class="hint">提示：雙擊球員可快速載入到輸入框修改。</div>
      </div>
    </section>

    <section id="tab-schedule" class="tab-pane">
      <div class="card">
        <h2 class="section-title">賽程安排</h2>
        <div class="row">
          <label for="roundInput">排程場次</label>
          <input id="roundInput" type="number" min="1" max="50" value="6" style="max-width:90px" />
          <button id="genScheduleBtn" class="btn">產生賽程</button>
        </div>
        <div id="scheduleOut" class="schedule-out"></div>
        <div class="row" style="margin-top:8px">
          <label for="matchSelect">載入場次</label>
          <select id="matchSelect" style="max-width:90px"></select>
          <button id="loadMatchBtn" class="btn">載入</button>
        </div>
      </div>
    </section>

    <section id="tab-scoreboard" class="tab-pane">
      <div class="card">
        <h2 class="section-title">比賽記分</h2>
        <div class="status-strip">
          <div class="score-line">
            <span id="scoreA">A 0</span>
            <span id="scoreMid" class="score-mid"> : </span>
            <span id="scoreB">0 B</span>
          </div>
          <div id="stateText" class="state-text">等待開球</div>
          <div id="serverText" class="server-text">目前發球：-</div>
          <div id="winBanner" class="banner"></div>
        </div>

        <div class="court-wrap"><canvas id="courtCanvas"></canvas></div>

        <div class="action-row" style="margin-top:10px">
          <button id="aWinBtn" class="btn">A 贏此球</button>
          <button id="bWinBtn" class="btn">B 贏此球</button>
          <button id="resetBtn" class="btn secondary">重設此場比分</button>
          <button id="nextMatchBtn" class="btn secondary" disabled>進入下一場</button>
        </div>

        <div id="hintText" class="hint">請先在賽程頁產生並載入一場比賽。</div>
        <div id="matchInfo" class="hint">目前場次：-</div>
      </div>
    </section>
  </div>

  <script>
    const state = {
      players: ["Player1", "Player2", "Player3", "Player4", "Player5", "Player6"],
      selectedPlayerIndex: -1,
      schedule: [],
      currentMatchIndex: -1,
      activeMatch: null,
      teamAPositions: [], // [left, right]
      teamBPositions: [], // [left, right]
      initialTeamA: [],
      initialTeamB: [],
      scoreA: 0,
      scoreB: 0,
      servingTeam: "A",
      openingServingTeam: "A",
      serverName: "",
      matchOver: false,
      winnerTeam: "",
      bannerTimer: null,
      bannerHideTimer: null,
    };

    const el = {
      tabBtns: [...document.querySelectorAll(".tab-btn")],
      tabPlayers: document.getElementById("tab-players"),
      tabSchedule: document.getElementById("tab-schedule"),
      tabScoreboard: document.getElementById("tab-scoreboard"),
      playerList: document.getElementById("playerList"),
      playerInput: document.getElementById("playerInput"),
      addPlayerBtn: document.getElementById("addPlayerBtn"),
      editPlayerBtn: document.getElementById("editPlayerBtn"),
      delPlayerBtn: document.getElementById("delPlayerBtn"),
      roundInput: document.getElementById("roundInput"),
      genScheduleBtn: document.getElementById("genScheduleBtn"),
      scheduleOut: document.getElementById("scheduleOut"),
      matchSelect: document.getElementById("matchSelect"),
      loadMatchBtn: document.getElementById("loadMatchBtn"),
      scoreA: document.getElementById("scoreA"),
      scoreB: document.getElementById("scoreB"),
      scoreMid: document.getElementById("scoreMid"),
      stateText: document.getElementById("stateText"),
      serverText: document.getElementById("serverText"),
      hintText: document.getElementById("hintText"),
      matchInfo: document.getElementById("matchInfo"),
      aWinBtn: document.getElementById("aWinBtn"),
      bWinBtn: document.getElementById("bWinBtn"),
      resetBtn: document.getElementById("resetBtn"),
      nextMatchBtn: document.getElementById("nextMatchBtn"),
      courtCanvas: document.getElementById("courtCanvas"),
      winBanner: document.getElementById("winBanner"),
    };

    function switchTab(name) {
      el.tabBtns.forEach((btn) => btn.classList.toggle("active", btn.dataset.tab === name));
      el.tabPlayers.classList.toggle("active", name === "players");
      el.tabSchedule.classList.toggle("active", name === "schedule");
      el.tabScoreboard.classList.toggle("active", name === "scoreboard");
      drawCourt();
    }

    function showAlert(msg) {
      window.alert(msg);
    }

    function renderPlayers() {
      el.playerList.innerHTML = "";
      state.players.forEach((name, idx) => {
        const row = document.createElement("div");
        row.className = "player-item" + (idx === state.selectedPlayerIndex ? " active" : "");
        row.textContent = name;
        row.onclick = () => {
          state.selectedPlayerIndex = idx;
          renderPlayers();
        };
        row.ondblclick = () => {
          state.selectedPlayerIndex = idx;
          el.playerInput.value = state.players[idx];
          renderPlayers();
        };
        el.playerList.appendChild(row);
      });
    }

    function addPlayer() {
      const name = el.playerInput.value.trim();
      if (!name) return;
      if (state.players.includes(name)) return showAlert("此名字已存在。");
      state.players.push(name);
      el.playerInput.value = "";
      renderPlayers();
    }

    function editPlayer() {
      const idx = state.selectedPlayerIndex;
      if (idx < 0) return showAlert("請先選擇一位球員。");
      const name = el.playerInput.value.trim();
      if (!name) return showAlert("請輸入新名字。");
      if (state.players.some((p, i) => i !== idx && p === name)) return showAlert("此名字已存在。");
      state.players[idx] = name;
      renderPlayers();
    }

    function deletePlayer() {
      const idx = state.selectedPlayerIndex;
      if (idx < 0) return;
      state.players.splice(idx, 1);
      state.selectedPlayerIndex = -1;
      renderPlayers();
    }

    function combos(arr, k) {
      const out = [];
      const n = arr.length;
      const pick = [];
      function dfs(start) {
        if (pick.length === k) {
          out.push(pick.slice());
          return;
        }
        for (let i = start; i < n; i += 1) {
          pick.push(arr[i]);
          dfs(i + 1);
          pick.pop();
        }
      }
      dfs(0);
      return out;
    }

    function sortedPair(a, b) {
      return [a, b].sort().join("|");
    }

    function buildFairSchedule(players, rounds) {
      const appearances = new Map(players.map((p) => [p, 0]));
      const teammateCount = new Map();
      const opponentCount = new Map();
      const recentPlayed = [];
      const results = [];

      for (let r = 0; r < rounds; r += 1) {
        let bestGroup = null;
        let bestScore = Number.POSITIVE_INFINITY;

        for (const group of combos(players, 4)) {
          const projected = new Map(appearances);
          group.forEach((p) => projected.set(p, (projected.get(p) || 0) + 1));
          const vals = [...projected.values()];
          const spread = Math.max(...vals) - Math.min(...vals);

          let repeatPenalty = 0;
          for (const [x, y] of combos(group, 2)) {
            repeatPenalty += teammateCount.get(sortedPair(x, y)) || 0;
          }
          const recentSet = new Set(recentPlayed.slice(-4));
          const recentPenalty = group.filter((p) => recentSet.has(p)).length;
          const score = spread * 100 + repeatPenalty * 8 + recentPenalty * 5;

          if (score < bestScore) {
            bestScore = score;
            bestGroup = group;
          }
        }

        if (!bestGroup) break;

        const parts = [
          [[bestGroup[0], bestGroup[1]], [bestGroup[2], bestGroup[3]]],
          [[bestGroup[0], bestGroup[2]], [bestGroup[1], bestGroup[3]]],
          [[bestGroup[0], bestGroup[3]], [bestGroup[1], bestGroup[2]]],
        ];

        let bestPart = null;
        let bestPartScore = Number.POSITIVE_INFINITY;

        for (const [ta, tb] of parts) {
          const teamRepeat = (teammateCount.get(sortedPair(ta[0], ta[1])) || 0) + (teammateCount.get(sortedPair(tb[0], tb[1])) || 0);
          let oppRepeat = 0;
          ta.forEach((x) => tb.forEach((y) => { oppRepeat += opponentCount.get(sortedPair(x, y)) || 0; }));
          const s = teamRepeat * 10 + oppRepeat * 3;
          if (s < bestPartScore) {
            bestPartScore = s;
            bestPart = [ta, tb];
          }
        }

        const [teamA, teamB] = bestPart;
        bestGroup.forEach((p) => {
          appearances.set(p, (appearances.get(p) || 0) + 1);
          recentPlayed.push(p);
        });

        teammateCount.set(sortedPair(teamA[0], teamA[1]), (teammateCount.get(sortedPair(teamA[0], teamA[1])) || 0) + 1);
        teammateCount.set(sortedPair(teamB[0], teamB[1]), (teammateCount.get(sortedPair(teamB[0], teamB[1])) || 0) + 1);
        teamA.forEach((x) => teamB.forEach((y) => {
          const k = sortedPair(x, y);
          opponentCount.set(k, (opponentCount.get(k) || 0) + 1);
        }));

        const rest = players.filter((p) => !bestGroup.includes(p));
        results.push({ teamA, teamB, resting: rest });
      }
      return results;
    }

    function renderSchedule() {
      const lines = [];
      state.schedule.forEach((m, i) => {
        lines.push(
          `========== 第 ${String(i + 1).padStart(2, "0")} 場 ==========`,
          `  A隊: ${m.teamA[0]} / ${m.teamA[1]}`,
          `  B隊: ${m.teamB[0]} / ${m.teamB[1]}`,
          `  休息: ${m.resting.length ? m.resting.join(", ") : "無"}`,
          ""
        );
      });
      el.scheduleOut.textContent = lines.join("\n");
      el.matchSelect.innerHTML = "";
      state.schedule.forEach((_, i) => {
        const op = document.createElement("option");
        op.value = String(i + 1);
        op.textContent = String(i + 1);
        el.matchSelect.appendChild(op);
      });
    }

    function generateSchedule() {
      if (state.players.length < 6) return showAlert("至少需要 6 人才方便輪替。");
      const rounds = Math.max(1, Math.min(50, Number(el.roundInput.value) || 6));
      state.schedule = buildFairSchedule(state.players.slice(), rounds);
      renderSchedule();
      if (state.schedule.length > 0) {
        el.matchSelect.value = "1";
        loadSelectedMatch();
        el.hintText.textContent = "賽程已產生，已載入第 1 場並切換至記分板。";
      }
    }

    function servicePlayerForSide(side) {
      if (side === "A") return state.scoreA % 2 === 0 ? state.teamAPositions[1] : state.teamAPositions[0];
      return state.scoreB % 2 === 0 ? state.teamBPositions[1] : state.teamBPositions[0];
    }

    function serviceCourtText(side) {
      if (side === "A") return state.scoreA % 2 === 0 ? "右發球區" : "左發球區";
      return state.scoreB % 2 === 0 ? "右發球區" : "左發球區";
    }

    function isMatchOver() {
      const top = Math.max(state.scoreA, state.scoreB);
      const lead = Math.abs(state.scoreA - state.scoreB);
      if (top >= 30) return true;
      return top >= 21 && lead >= 2;
    }

    function loadSelectedMatch() {
      if (!state.schedule.length) return showAlert("請先產生賽程。");
      const idx = Number(el.matchSelect.value) - 1;
      if (idx < 0 || idx >= state.schedule.length) return;
      state.currentMatchIndex = idx;
      state.activeMatch = state.schedule[idx];
      state.teamAPositions = state.activeMatch.teamA.slice();
      state.teamBPositions = state.activeMatch.teamB.slice();
      state.initialTeamA = state.teamAPositions.slice();
      state.initialTeamB = state.teamBPositions.slice();
      resetScore(true);
      el.hintText.textContent = `已載入第 ${idx + 1} 場`;
      el.matchInfo.textContent = `目前場次：第 ${idx + 1} 場 / 共 ${state.schedule.length} 場`;
      el.nextMatchBtn.disabled = true;
      switchTab("scoreboard");
    }

    function loadNextMatch() {
      if (!state.schedule.length) return;
      const next = state.currentMatchIndex + 1;
      if (next >= state.schedule.length) {
        el.nextMatchBtn.disabled = true;
        el.hintText.textContent = "已是最後一場。";
        return;
      }
      el.matchSelect.value = String(next + 1);
      loadSelectedMatch();
    }

    function resetScore(randomizeServer = false) {
      state.scoreA = 0;
      state.scoreB = 0;
      state.matchOver = false;
      state.winnerTeam = "";
      hideWinBanner();
      if (state.activeMatch) {
        state.teamAPositions = state.initialTeamA.slice();
        state.teamBPositions = state.initialTeamB.slice();
        if (randomizeServer) state.openingServingTeam = Math.random() < 0.5 ? "A" : "B";
        state.servingTeam = state.openingServingTeam;
        state.serverName = servicePlayerForSide(state.servingTeam);
        el.hintText.textContent = `開局第一球：${state.servingTeam} 隊右發球區`;
      }
      renderScoreboard();
    }

    function rallyWon(winner) {
      if (!state.activeMatch) return showAlert("請先在賽程頁載入比賽。");
      if (state.matchOver) return;

      if (winner === "A") state.scoreA += 1;
      else state.scoreB += 1;

      if (winner === state.servingTeam) {
        if (winner === "A") {
          [state.teamAPositions[0], state.teamAPositions[1]] = [state.teamAPositions[1], state.teamAPositions[0]];
        } else {
          [state.teamBPositions[0], state.teamBPositions[1]] = [state.teamBPositions[1], state.teamBPositions[0]];
        }
        state.serverName = servicePlayerForSide(winner);
      } else {
        state.servingTeam = winner;
        state.serverName = servicePlayerForSide(winner);
      }

      if (isMatchOver()) {
        state.matchOver = true;
        state.winnerTeam = state.scoreA > state.scoreB ? "A" : "B";
        state.serverName = "";
        if (state.currentMatchIndex + 1 < state.schedule.length) {
          el.nextMatchBtn.disabled = false;
          el.hintText.textContent = `本場結束：${state.winnerTeam} 隊獲勝`;
        } else {
          el.nextMatchBtn.disabled = true;
          el.hintText.textContent = `本場結束：${state.winnerTeam} 隊獲勝（已是最後一場）`;
        }
        showWinBanner(`${state.winnerTeam} 隊 WIN!`);
      }

      renderScoreboard();
    }

    function renderScoreboard() {
      el.scoreA.textContent = `A ${state.scoreA}`;
      el.scoreB.textContent = `${state.scoreB} B`;

      if (state.scoreA > state.scoreB) {
        el.scoreA.style.color = "var(--lead-a)";
        el.scoreB.style.color = "var(--trail)";
      } else if (state.scoreB > state.scoreA) {
        el.scoreA.style.color = "var(--trail)";
        el.scoreB.style.color = "var(--lead-b)";
      } else {
        el.scoreA.style.color = "var(--neutral)";
        el.scoreB.style.color = "var(--neutral)";
      }

      if (state.matchOver) {
        el.stateText.textContent = "比賽結束";
        el.stateText.style.color = "var(--serve)";
        el.serverText.textContent = `勝方：${state.winnerTeam} 隊`;
      } else if (state.serverName) {
        el.stateText.textContent = "比賽進行中";
        el.stateText.style.color = "var(--muted)";
        el.serverText.textContent = `目前發球：${state.serverName}（${state.servingTeam}隊 / ${serviceCourtText(state.servingTeam)}）`;
      } else {
        el.stateText.textContent = "等待開球";
        el.stateText.style.color = "var(--muted)";
        el.serverText.textContent = "目前發球：-";
      }
      drawCourt();
    }

    function showWinBanner(text) {
      hideWinBanner();
      el.winBanner.textContent = text;
      el.winBanner.classList.add("show");
      state.bannerHideTimer = setTimeout(hideWinBanner, 3200);
    }

    function hideWinBanner() {
      if (state.bannerTimer) clearInterval(state.bannerTimer);
      if (state.bannerHideTimer) clearTimeout(state.bannerHideTimer);
      state.bannerTimer = null;
      state.bannerHideTimer = null;
      el.winBanner.classList.remove("show");
      el.winBanner.textContent = "";
    }

    function fitNameByPixels(ctx, name, maxPx) {
      if (ctx.measureText(name).width <= maxPx) return name;
      const dots = "…";
      let out = "";
      for (const ch of name) {
        const trial = out + ch + dots;
        if (ctx.measureText(trial).width > maxPx) break;
        out += ch;
      }
      return out ? out + dots : dots;
    }

    function drawPlayer(ctx, x, y, name, maxNameWidth) {
      ctx.beginPath();
      ctx.arc(x, y, 12, 0, Math.PI * 2);
      ctx.fillStyle = "#0e2b1d";
      ctx.fill();
      ctx.lineWidth = 1;
      ctx.strokeStyle = "#e8fff4";
      ctx.stroke();

      const fontSize = el.courtCanvas.clientWidth < 390 ? 12 : 13;
      ctx.font = `700 ${fontSize}px Segoe UI`;
      ctx.fillStyle = "#f6fff9";
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      const nm = fitNameByPixels(ctx, name, maxNameWidth);
      ctx.fillText(nm, x, y + 16, maxNameWidth);
    }

    function serveMark(ctx, x, y) {
      ctx.beginPath();
      ctx.arc(x, y, 18, 0, Math.PI * 2);
      ctx.strokeStyle = "#ffd24d";
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.font = "700 14px Segoe UI";
      ctx.fillStyle = "#ffd24d";
      ctx.textAlign = "center";
      ctx.fillText("發", x, y - 22);
    }

    function drawCourt() {
      const cvs = el.courtCanvas;
      const ratio = window.devicePixelRatio || 1;
      const w = Math.max(280, cvs.clientWidth);
      const h = Math.max(240, cvs.clientHeight);
      cvs.width = Math.floor(w * ratio);
      cvs.height = Math.floor(h * ratio);
      const ctx = cvs.getContext("2d");
      ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
      ctx.clearRect(0, 0, w, h);

      const margin = 20;
      const x1 = margin, y1 = margin, x2 = w - margin, y2 = h - margin;
      const midX = Math.floor((x1 + x2) / 2);
      const midY = Math.floor((y1 + y2) / 2);

      ctx.fillStyle = "#2b9a61";
      ctx.strokeStyle = "#effff5";
      ctx.lineWidth = 3;
      ctx.fillRect(x1, y1, x2 - x1, y2 - y1);
      ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);

      ctx.fillStyle = "#f2f7f4";
      ctx.fillRect(midX - 5, y1, 10, y2 - y1); // 中線球網

      ctx.strokeStyle = "#effff5";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x1, midY); ctx.lineTo(x2, midY);
      ctx.moveTo(midX - 70, y1); ctx.lineTo(midX - 70, y2);
      ctx.moveTo(midX + 70, y1); ctx.lineTo(midX + 70, y2);
      ctx.stroke();

      ctx.font = "700 12px Segoe UI";
      ctx.fillStyle = "#f6fff9";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("A隊", (x1 + midX) / 2, y1 - 8);
      ctx.fillText("B隊", (midX + x2) / 2, y1 - 8);
      ctx.font = "12px Segoe UI";
      ctx.fillStyle = "#bfd8ca";
      ctx.fillText("★ 中線為球網 / 發球者外圈高亮", (x1 + x2) / 2, y2 + 12);

      if (!state.teamAPositions.length) return;

      const halfW = midX - x1;
      const xOffset = Math.max(24, Math.min(45, Math.floor(halfW / 3)));
      const yOffset = Math.max(34, Math.min(50, Math.floor((y2 - y1) / 4)));
      const nameWidth = Math.max(40, halfW - (xOffset + 18) * 2);

      // 面向球網判定左右
      const aLeft = [(x1 + midX) / 2 - xOffset, midY - yOffset];
      const aRight = [(x1 + midX) / 2 + xOffset, midY + yOffset];
      const bLeft = [(midX + x2) / 2 - xOffset, midY + yOffset];
      const bRight = [(midX + x2) / 2 + xOffset, midY - yOffset];

      const [aLeftName, aRightName] = state.teamAPositions;
      const [bLeftName, bRightName] = state.teamBPositions;
      drawPlayer(ctx, aLeft[0], aLeft[1], aLeftName, nameWidth);
      drawPlayer(ctx, aRight[0], aRight[1], aRightName, nameWidth);
      drawPlayer(ctx, bLeft[0], bLeft[1], bLeftName, nameWidth);
      drawPlayer(ctx, bRight[0], bRight[1], bRightName, nameWidth);

      if (state.serverName === aLeftName) serveMark(ctx, aLeft[0], aLeft[1]);
      else if (state.serverName === aRightName) serveMark(ctx, aRight[0], aRight[1]);
      else if (state.serverName === bLeftName) serveMark(ctx, bLeft[0], bLeft[1]);
      else if (state.serverName === bRightName) serveMark(ctx, bRight[0], bRight[1]);
    }

    function bindEvents() {
      el.tabBtns.forEach((btn) => btn.addEventListener("click", () => switchTab(btn.dataset.tab)));
      el.addPlayerBtn.addEventListener("click", addPlayer);
      el.editPlayerBtn.addEventListener("click", editPlayer);
      el.delPlayerBtn.addEventListener("click", deletePlayer);
      el.genScheduleBtn.addEventListener("click", generateSchedule);
      el.loadMatchBtn.addEventListener("click", loadSelectedMatch);
      el.aWinBtn.addEventListener("click", () => rallyWon("A"));
      el.bWinBtn.addEventListener("click", () => rallyWon("B"));
      el.resetBtn.addEventListener("click", () => resetScore(false));
      el.nextMatchBtn.addEventListener("click", loadNextMatch);
      window.addEventListener("resize", drawCourt);
    }

    renderPlayers();
    bindEvents();
    renderScoreboard();
  </script>
</body>
</html>
